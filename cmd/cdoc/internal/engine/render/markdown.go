package render

import (
	"fmt"
	"sort"
	"strings"

	"github.com/rudderlabs/rudder-go-kit/cmd/cdoc/internal/engine/model"
	"github.com/rudderlabs/rudder-go-kit/config"
)

// FormatMarkdown generates the markdown documentation from extracted entries.
func FormatMarkdown(entries []model.Entry, envPrefix string) string {
	groupNames := []string{}
	groupMap := make(map[string][]model.Entry)
	groupOrderMap := make(map[string]int) // group name â†’ sort order

	for _, entry := range entries {
		group := entry.Group
		if group == "" {
			group = "Ungrouped"
		}
		if _, ok := groupMap[group]; !ok {
			groupNames = append(groupNames, group)
		}
		groupMap[group] = append(groupMap[group], entry)
		if entry.GroupOrder != 0 && groupOrderMap[group] == 0 {
			groupOrderMap[group] = entry.GroupOrder
		}
	}

	// Sort groups: ordered groups first (by order), then unordered alphabetically.
	sort.SliceStable(groupNames, func(i, j int) bool {
		oi, oj := groupOrderMap[groupNames[i]], groupOrderMap[groupNames[j]]
		if oi != 0 && oj != 0 {
			return oi < oj
		}
		if oi != 0 {
			return true
		}
		if oj != 0 {
			return false
		}
		return groupNames[i] < groupNames[j]
	})

	// Sort entries within each group by primary key.
	for _, groupEntries := range groupMap {
		sort.Slice(groupEntries, func(i, j int) bool {
			return groupEntries[i].PrimaryKey < groupEntries[j].PrimaryKey
		})
	}

	var sb strings.Builder
	sb.WriteString("# Configuration\n\n")
	fmt.Fprintf(&sb, "All configuration is read via environment variables with the `%s_` prefix, or via a configuration file.\n\n", envPrefix)
	sb.WriteString("<!-- This file is auto-generated by cdoc. Do not edit manually. -->\n\n")

	// If all entries are ungrouped, skip group headers entirely.
	singleUngrouped := len(groupNames) == 1 && groupNames[0] == "Ungrouped"

	for _, group := range groupNames {
		groupEntries := groupMap[group]
		if !singleUngrouped {
			fmt.Fprintf(&sb, "## %s\n\n", group)
		}
		sb.WriteString("| Config variable | Env variable | Default | Description |\n")
		sb.WriteString("|---|---|---|---|\n")

		for _, entry := range groupEntries {
			configColumn := formatConfigVarColumn(entry)
			envColumn := formatEnvVarColumn(entry, envPrefix)
			defaultColumn := formatDefault(entry.Default)
			description := entry.Description
			if entry.Reloadable {
				description = "ðŸ”„ " + description
			}
			description = escapeMarkdownTableText(description)
			fmt.Fprintf(&sb, "| %s | %s | %s | %s |\n", configColumn, envColumn, defaultColumn, description)
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// formatConfigVarColumn renders config keys for the markdown table.
func formatConfigVarColumn(entry model.Entry) string {
	var parts []string
	for _, key := range entry.ConfigKeys {
		parts = append(parts, formatCodeCell(key))
	}
	if len(parts) == 0 {
		// If all keys are env-var style, show the primary key.
		return formatCodeCell(entry.PrimaryKey)
	}
	return strings.Join(parts, "<br>")
}

// formatEnvVarColumn renders derived and explicit environment variable keys.
func formatEnvVarColumn(entry model.Entry, envPrefix string) string {
	var parts []string

	// Add derived env vars from config keys.
	seen := make(map[string]bool)
	for _, key := range entry.ConfigKeys {
		derived := config.ConfigKeyToEnv(envPrefix, key)
		if !seen[derived] {
			parts = append(parts, formatCodeCell(derived))
			seen[derived] = true
		}
	}

	// Add explicit env keys that are different from derived ones.
	for _, key := range entry.EnvKeys {
		if !seen[key] {
			parts = append(parts, formatCodeCell(key))
			seen[key] = true
		}
	}

	return strings.Join(parts, "<br>")
}

// formatDefault renders the default value column.
func formatDefault(def string) string {
	return formatCodeCell(def)
}

// normalizeLineEndings converts CRLF/CR to LF for stable markdown formatting.
func normalizeLineEndings(value string) string {
	value = strings.ReplaceAll(value, "\r\n", "\n")
	value = strings.ReplaceAll(value, "\r", "\n")
	return value
}

// escapeMarkdownTableText escapes markdown table metacharacters and newlines.
func escapeMarkdownTableText(value string) string {
	value = normalizeLineEndings(value)
	value = strings.ReplaceAll(value, "\n", "<br>")
	value = strings.ReplaceAll(value, "|", "\\|")
	return value
}

// formatCodeCell renders multi-line content as inline-code lines joined by <br>.
func formatCodeCell(value string) string {
	value = normalizeLineEndings(value)
	lines := strings.Split(value, "\n")
	parts := make([]string, 0, len(lines))
	for _, line := range lines {
		parts = append(parts, formatInlineCode(line))
	}
	return strings.Join(parts, "<br>")
}

// formatInlineCode wraps a string in a safe backtick delimiter sequence.
func formatInlineCode(value string) string {
	if value == "" {
		return ""
	}
	maxBackticks := 0
	currentRun := 0
	for _, ch := range value {
		if ch == '`' {
			currentRun++
			if currentRun > maxBackticks {
				maxBackticks = currentRun
			}
			continue
		}
		currentRun = 0
	}

	delimiter := strings.Repeat("`", maxBackticks+1)
	if strings.HasPrefix(value, " ") || strings.HasSuffix(value, " ") {
		value = " " + value + " "
	}
	return delimiter + value + delimiter
}
